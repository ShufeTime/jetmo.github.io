{"meta":{"title":"Leejia Blog","subtitle":"君子之心，常怀敬畏.","description":null,"author":"Leejia","url":"https://www.leejia.me"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-09-23T03:53:56.003Z","updated":"2018-09-22T02:27:26.706Z","comments":false,"path":"/404.html","permalink":"https://www.leejia.me//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-09-24T06:28:19.440Z","updated":"2018-09-24T06:28:19.440Z","comments":false,"path":"about/index.html","permalink":"https://www.leejia.me/about/index.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930&#123; name: 'Leejia' age: 25, gender: '男', profession: '后端, 爬虫', experience: '2年', address: '浙江省杭州市', education: '本科', github: 'https://github.com/shufetime', blog: 'https://www.leejia.me', email: 'molee@live.com', description: '君子之心，常怀敬畏.', skills: [ ['Python', 'Javascript', 'jQuery', 'Vue', 'Css', 'PHP'], ['Git', 'Docker', 'Celery'], ['Flask', 'Tornado', 'Django'], ['Mysql', 'MongoDB', 'Redis'] ['WordPress', 'Typecho', 'Hexo', 'XiunoPHP'], ], devTools: [ ['Pycharm', 'Visual Studio Code', 'Sublime Text', 'Notepad++','Jupyter-notebook', 'Postman', 'HTTP'], ['Chrome DevTools', 'Fiddler', 'Charles', 'WireShark'], ['SourceTree', 'StartUML', 'Navicat Premium'], ['ShadowsocksX', 'Typora', 'Expressions'], ['VMware Fusion', 'XMind ZEN', 'SnippetsLab', 'Dash', 'iTerm2'], ['zsh', 'oh-my-zsh', 'vim', ] ] &#125;"},{"title":"分类","date":"2018-09-23T03:53:56.110Z","updated":"2018-09-21T06:59:01.996Z","comments":false,"path":"categories/index.html","permalink":"https://www.leejia.me/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-09-23T03:53:56.105Z","updated":"2018-09-21T06:59:01.996Z","comments":false,"path":"books/index.html","permalink":"https://www.leejia.me/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-09-23T03:53:56.121Z","updated":"2018-09-21T06:59:01.996Z","comments":true,"path":"links/index.html","permalink":"https://www.leejia.me/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-09-23T03:53:56.126Z","updated":"2018-09-21T06:59:01.996Z","comments":false,"path":"repository/index.html","permalink":"https://www.leejia.me/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-23T03:53:56.131Z","updated":"2018-09-21T06:59:01.997Z","comments":false,"path":"tags/index.html","permalink":"https://www.leejia.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mac安装pyv8模块","slug":"mac安装pyv8模块","date":"2018-10-08T05:59:18.000Z","updated":"2018-10-08T06:02:37.364Z","comments":true,"path":"code/install_pyv8.html","link":"","permalink":"https://www.leejia.me/code/install_pyv8.html","excerpt":"","text":"安装1pip install -e git://github.com/brokenseal/PyV8-OS-X#egg=pyv8 保持网络畅通, 然后等待… 就成功了.12345678910111213Last login: Mon Oct 8 13:31:59 on ttys000Page: www.leejia.meNickName: Leejia➜ ~ pip install -e git://github.com/brokenseal/PyV8-OS-X#egg=pyv8 Looking in indexes: http://mirrors.aliyun.com/pypi/simpleObtaining pyv8 from git+git://github.com/brokenseal/PyV8-OS-X#egg=pyv8 Cloning git://github.com/brokenseal/PyV8-OS-X to ./src/pyv8Installing collected packages: pyv8 Running setup.py develop for pyv8Successfully installed pyv8You are using pip version 18.0, however version 18.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.➜ ~ ipython3 测试12345678➜ ~ ipython3Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 05:52:31) Type 'copyright', 'credits' or 'license' for more informationIPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: import pyv8In [2]: import pyv8 没有报错就表示成功了.","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.leejia.me/tags/python/"},{"name":"mac","slug":"mac","permalink":"https://www.leejia.me/tags/mac/"},{"name":"pyv8","slug":"pyv8","permalink":"https://www.leejia.me/tags/pyv8/"}]},{"title":"博客启用新主题","slug":"博客启用新主题","date":"2018-09-22T02:08:03.000Z","updated":"2018-09-23T01:01:17.827Z","comments":true,"path":"code/blog_use_new_theme.html","link":"","permalink":"https://www.leejia.me/code/blog_use_new_theme.html","excerpt":"","text":"博客之前一直使用的是Maupassant.非常感谢屠城,提供这款漂亮简洁的主题. 今天启用了cofess 开发的主题pure .这款主题在Hexo官方的主题库中有.一款非常漂亮的主题.","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.leejia.me/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"https://www.leejia.me/tags/theme/"}]},{"title":"Hexo生成的RSS文件atom.xml报错","slug":"Hexo生成的RSS文件atmo-xml报错","date":"2018-09-21T10:38:33.000Z","updated":"2018-09-24T13:50:16.161Z","comments":true,"path":"code/id_rss_vscode_bug.html","link":"","permalink":"https://www.leejia.me/code/id_rss_vscode_bug.html","excerpt":"","text":"Hexo 生成的 RSS 的 atom.xml 报错 PCDATA invalid Char value，产生这样的原因就是 Markdown 文件中有特殊字符。 插件我使用 hexo-generator-feed 来生成 Feed 的atom.xml文件 错误12345在浏览器中查看 atom.xml，发现报错，信息如下。This page contains the following errors:error on line 264 at column 168: PCDATA invalid Char value 8Below is a rendering of the page up to the first error. 因为是使用的是vscode直接编辑的,这个编辑器有个问题会产生^H这个字符,这个导致xml无法渲染.而且在vscode,typora中这个字符都不会显示, 用vim编辑器打开就可以看到^H 解决办法用vim编辑器打开就可以看到^H然后挨个删掉. 然后在使用命令重新生成一下atom.xml文件 1hexo g","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"rss","slug":"rss","permalink":"https://www.leejia.me/tags/rss/"},{"name":"vscode","slug":"vscode","permalink":"https://www.leejia.me/tags/vscode/"},{"name":"hexo","slug":"hexo","permalink":"https://www.leejia.me/tags/hexo/"}]},{"title":"python中print底层调用了什么方法","slug":"python中print和input底层调用了什么方法","date":"2018-09-20T07:29:15.000Z","updated":"2018-09-20T07:53:44.060Z","comments":true,"path":"python/python_source_code.html","link":"","permalink":"https://www.leejia.me/python/python_source_code.html","excerpt":"","text":"print函数print()底层调用的是sys.stdout.write()来实现打印字符串控制台,但是print()又不同于sys.stdout.write() 1234567891011121314151617# -*- coding: utf-8 -*-# @Author : Leejia# @Blog ：www.leejia.meimport sysprint(__file__)print('hello, Leejia')print('-' * 10)sys.stdout.write('hello, Leejia')print('leeeeeee')# 输出结果:/Users/jetmo/Documents/Code/shops/print_input_test.pyhello, Leejia----------hello, LeejialeeeeeeeProcess finished with exit code 0 可以看看出来, sys.stdout.write 是没有自动换行的 12345sys.stdout.write('hello, Leejia')print('leeeeeee')# 结果: hello, Leejialeeeeeee sys.stdout.write 只能接受一个参数 1234567sys.stdout.write('hello, Leejia', 'test')# 结果:Traceback (most recent call last): File \"/Users/jetmo/Documents/Code/shops/print_input_test.py\", line 12, in &lt;module&gt; sys.stdout.write('hello, Leejia', 'test')TypeError: write() takes exactly one argument (2 given) sys.stdout.write 只能接受字符串 1234567sys.stdout.write(123)# 结果Traceback (most recent call last): File \"/Users/jetmo/Documents/Code/shops/print_input_test.py\", line 14, in &lt;module&gt; sys.stdout.write(123)TypeError: write() argument must be str, not int","categories":[{"name":"python","slug":"python","permalink":"https://www.leejia.me/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.leejia.me/tags/python/"},{"name":"input","slug":"input","permalink":"https://www.leejia.me/tags/input/"},{"name":"底层源码","slug":"底层源码","permalink":"https://www.leejia.me/tags/底层源码/"}]},{"title":"关于ubuntu清理垃圾","slug":"关于ubuntu清理垃圾","date":"2018-09-18T02:18:14.000Z","updated":"2018-09-18T05:35:35.749Z","comments":true,"path":"code/clean_your_ubuntu.html","link":"","permalink":"https://www.leejia.me/code/clean_your_ubuntu.html","excerpt":"","text":"MBP上安装了ubuntu16.04虚拟机,随着使用时间越长, 导致缓存,无效的配置文件等占用空间特别的大.目前有22G多.于是在网上找了一个清理方法. Ubuntu Linux与Windows系统不同，Ubuntu Linux不会产生无用垃圾文件，但是在升级缓存中，Ubuntu Linux不会自动删除这些文件，今天就来说说这些垃圾文件清理方法。 非常有用的清理命令：1234sudo apt-get autoclean # --清理旧版本的软件缓存 OK(已经卸载掉的软件包)sudo apt-get clean # --清理所有软件缓存 OK(电脑上存储的安装包)sudo apt-get autoremove # --删除系统不再使用的孤立软件 OK(已经卸载了，但是一些只有它依赖而别的软件包都不需要的软件包) 这三个命令主要清理升级缓存以及无用包的。 清理Linux下孤立的包：1234图形界面下我们可以用：gtkorphansudo apt-get install gtkorphan -y终端命令下我们可以用：deborphansudo apt-get install deborphan -y 删除多余的内核(在1中已清理)(在终端中输入uname -a，然后看其显示的现用内核版本是多少)(不删除掉老的内核，以便于使用新升级的内核无法启动时，你能马上使用老内核进行启动，不至于导致你无法进入系统的悲剧。不过在你升级完毕，重启后能进入系统后，说明新内核已经很好的兼容了你的电脑，那么你就可以放心大胆的删除掉老内核) 清理无效软件libreoffice是一套类似于微软office的免费办公套件，不过无论界面交互还是执行性能都还有很大的提升空间，卸载libreoffice可以释放300M左右的磁盘空间123456789101112131415161718192021222324252627282930313233343536373839404142sudo apt-get -y purge libreoffice* #办公套件 sudo apt-get -y purge thunderbird* # 邮箱软件sudo apt-get -y purge gnome-power-manager #电源统计 sudo apt-get -y purge deja-dup #备份 sudo apt-get -y purge bluez* #卸载蓝牙 sudo apt-get -y purge simple-scan #扫描 sudo apt-get -y purge hplip* #打印 sudo apt-get -y purge printer-driver* #打印驱动 sudo apt-get -y purge rhythmbox* #音乐播放 sudo apt-get -y purge gnome-orca #屏幕阅读 sudo apt-get -y purge onboard #屏幕键盘 sudo apt-get -y purge aisleriot #纸牌王 sudo apt-get -y purge gnome-sudoku #数独 sudo apt-get purge stardict* # 星际译王sudo apt-get purge totem # 卸载视频播放器sudo apt-get purge Shotwell* # 一个图片管理工具sudo apt-get purge imagemagic*# 下面的谨慎操作!!# aptitude remove totem # 卸载视频播放器# 清单(sudo apt-get purge 下面的名称)libreoffice-common libreoffice（可以换 WPS ，apt purge libreoffice-common）unity-webapps-common Amazon 链接thunderbird 雷鸟邮件客户端totem 自带的播放器rhythmbox 自带的音乐播放器empathy 自带的即时聊天应用brasero 自带的光盘刻录器simple-scan 扫描仪gnome-mahjongg 对对碰游戏aisleriot 纸牌游戏gnome-mines 扫雷游戏cheese webcam 应用gnome-sudoku 数独游戏transmission-common BT 客户端gnome-orca 屏幕阅读webbrowser-app Ubuntu自带的浏览器（有了 chrome 和 Firefox 根本用不到这个）landscape-client-ui-install landscape 远程控制软件deja-dup 备份onboard 屏幕键盘imagemagic* 清理无效配置文件1dpkg -l |grep ^rc|awk '&#123;print $2&#125;' |sudo xargs dpkg -P 附录包管理的临时文件目录:包在 /var/cache/apt/archives没有下载完的在 /var/cache/apt/archives/partial 在卸载软件的时候，尽可能使用sudo apt-get purge xxxxx（xxxx为要卸载的软件名），这样可以将软件以及它的配置文件均卸载干净。 救命稻草执行这一行的时候可能会关联其他软件这个时候如果重启ubuntu会出现:#谨慎使用: aptitude remove totem # 卸载视频播放器登录后无dash,无启动栏launch,无menu bar只有桌面背景的快速解决办法 解决方案： 链接ubuntu (0)使用shell远程链接ubuntu(前提知道ip地址) (1)或者尝试用 ctrl + alt + t 打开命令行 安装compizconfig-settings-manager 1sudo apt-get install compizconfig-settings-manager 安装 unity 1sudo apt-get -f install &amp;&amp; sudo apt-get --reinstall install unity 重启 1sudo shutdown now -r","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.leejia.me/tags/ubuntu/"},{"name":"mac","slug":"mac","permalink":"https://www.leejia.me/tags/mac/"},{"name":"clean","slug":"clean","permalink":"https://www.leejia.me/tags/clean/"},{"name":"垃圾","slug":"垃圾","permalink":"https://www.leejia.me/tags/垃圾/"}]},{"title":"定制mac终端欢迎页","slug":"定制mac终端欢迎页","date":"2018-09-17T05:10:20.000Z","updated":"2018-09-17T05:16:57.181Z","comments":true,"path":"code/diy_your_terminal.html","link":"","permalink":"https://www.leejia.me/code/diy_your_terminal.html","excerpt":"","text":"mac上无论是npm、git还是Jekyll都会用到终端，虽然坑多，但折腾不止！遂苦中作乐。 配置步骤 快捷键control+space唤出Spotlight，搜索terminal打开终端 12cd /etc #进入目录sudo pico motd #输入密码后进入修改页面 粘贴内容如下 123456789101112131415161718192021 _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : `- \\`.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / /======`-.____`-.___\\_____/___.-`____.-'====== `=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 🙏 永无BUG 保存: 12control + X 然后输入y 然后可能需要你输入保存的文件名填写motd 重启终端看效果吧.自带的tetminal和iterm都可以看到效果.","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://www.leejia.me/tags/mac/"},{"name":"terminal","slug":"terminal","permalink":"https://www.leejia.me/tags/terminal/"},{"name":"终端","slug":"终端","permalink":"https://www.leejia.me/tags/终端/"}]},{"title":"docker安装和使用","slug":"docker安装和使用","date":"2018-09-16T12:22:58.000Z","updated":"2018-09-17T02:27:37.376Z","comments":true,"path":"code/install_docker_and_use.html","link":"","permalink":"https://www.leejia.me/code/install_docker_and_use.html","excerpt":"","text":"ubuntu安装更新ubuntu的apt源索引1sudo apt-get update 安装包允许apt通过HTTPS使用仓库12345sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 添加Docker官方GPG key1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置Docker稳定版仓库1234sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 添加仓库后，更新apt源索引1sudo apt-get update 安装最新版Docker CE（社区版）1sudo apt-get install docker-ce 检查Docker CE是否安装正确1sudo docker run hello-world 出现如下信息，表示安装成功12345678910111213141516171819202122Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 启动与停止安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令 启动docker1sudo service docker start 停止docker1sudo service docker stop 重启docker1sudo service docker restart","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.leejia.me/tags/docker/"}]},{"title":"开发记录之django框架数据库迁移","slug":"开发记录之django框架数据库迁移","date":"2018-09-16T02:47:14.000Z","updated":"2018-09-16T02:53:29.300Z","comments":true,"path":"django/djang_migrate_dababase.html","link":"","permalink":"https://www.leejia.me/django/djang_migrate_dababase.html","excerpt":"","text":"记录今天新建了一个数据库模型, 但是却怎么也迁移不成功.显示:没有任何改变..12(shops_py3) ➜ shops git:(dev) ✗ python manage.py makemigrationsNo changes detected 后来忽然想到一个问题: 我只是建立了数据模型,但是并没有个和django框架本身建立联系.很显然我没有注册app….1234INSTALLED_APPS = [ .... 'areas.apps.AreasConfig',] 注册后再执行果然妥妥的成功了~~~1(shops_py3) ➜ shops git:(dev) ✗ python manage.py makemigrations 12345(shops_py3) ➜ shops git:(dev) ✗ python manage.py makemigrationsMigrations for 'areas': shops/apps/areas/migrations/0001_initial.py - Create model Area(shops_py3) ➜ shops git:(dev) ✗ python manage migrate 总结开发一定要心细. 细节问题不能出错…因为真的很难排查…","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"migrate","slug":"migrate","permalink":"https://www.leejia.me/tags/migrate/"},{"name":"database","slug":"database","permalink":"https://www.leejia.me/tags/database/"}]},{"title":"关于开发过程的感受","slug":"关于开发过程的感受","date":"2018-09-15T13:02:53.000Z","updated":"2018-09-17T02:28:44.793Z","comments":true,"path":"code/develop_and_think.html","link":"","permalink":"https://www.leejia.me/code/develop_and_think.html","excerpt":"","text":"胡言乱语开发遇到解不开的问题,多看源码.看源码解题,一不要太爽的事情.哈哈哈.","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"感受","slug":"感受","permalink":"https://www.leejia.me/tags/感受/"},{"name":"源码","slug":"源码","permalink":"https://www.leejia.me/tags/源码/"}]},{"title":"mac升级系统后出现xcrun error解决办法","slug":"mac升级系统后出现xcrun error解决办法","date":"2018-09-15T06:12:50.000Z","updated":"2018-09-17T02:31:52.004Z","comments":true,"path":"code/xcrun_error.html","link":"","permalink":"https://www.leejia.me/code/xcrun_error.html","excerpt":"","text":"现象1xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决办法1xcode-select --install","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"xcrun","slug":"xcrun","permalink":"https://www.leejia.me/tags/xcrun/"},{"name":"code","slug":"code","permalink":"https://www.leejia.me/tags/code/"}]},{"title":"找BUG事件快乐的事情","slug":"找BUG事件快乐的事情","date":"2018-09-12T12:16:31.000Z","updated":"2018-09-17T02:29:04.032Z","comments":true,"path":"code/fing_bug.html","link":"","permalink":"https://www.leejia.me/code/fing_bug.html","excerpt":"","text":"开发中出现BUG是非常正常是事情,找BUG也是非常爽的过程~ 流程: 打开QQ音乐 打断点调试 看源码 实现不行再csdn,google….. 今天在开发django找回密码的功能.在进入修改密码页面之前需要针对当前用户生成access_token.错误的把JTF的接口调用过来了…… 打断点排查顺利解决~","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://www.leejia.me/tags/bug/"}]},{"title":"mac系统下django日志如有中文报错的解决方法","slug":"mac系统下django日志如有中文报错的解决方法","date":"2018-09-09T12:36:10.000Z","updated":"2018-09-21T10:34:42.346Z","comments":true,"path":"django/django_logging_error.html","link":"","permalink":"https://www.leejia.me/django/django_logging_error.html","excerpt":"","text":"出现的bugdjango使用DRF框架。配置日志，如果有中文控制台会报错，但是在因为下就不会出现这样的错误，经过排查可以确定的是中文导致的bug如下为完整报错信息，后面也会贴出核心错误信息. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374--- Logging error ---Traceback (most recent call last): File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/logging/__init__.py\", line 994, in emit stream.write(msg)UnicodeEncodeError: 'ascii' codec can't encode characters in position 38-39: ordinal not in range(128)Call stack: File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py\", line 884, in _bootstrap self._bootstrap_inner() File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py\", line 916, in _bootstrap_inner self.run() File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py\", line 864, in run self._target(*self._args, **self._kwargs) File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socketserver.py\", line 639, in process_request_thread self.finish_request(request, client_address) File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socketserver.py\", line 361, in finish_request self.RequestHandlerClass(request, client_address, self) File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/socketserver.py\", line 696, in __init__ self.handle() File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/servers/basehttp.py\", line 155, in handle handler.run(self.server.get_app()) File \"/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/wsgiref/handlers.py\", line 137, in run self.result = application(self.environ, self.start_response) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/contrib/staticfiles/handlers.py\", line 63, in __call__ return self.application(environ, start_response) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/wsgi.py\", line 157, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/base.py\", line 124, in get_response response = self._middleware_chain(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/utils/deprecation.py\", line 140, in __call__ response = self.get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/exception.py\", line 41, in inner response = get_response(request) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/core/handlers/base.py\", line 185, in _get_response response = wrapped_callback(request, *callback_args, **callback_kwargs) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/views/decorators/csrf.py\", line 58, in wrapped_view return view_func(*args, **kwargs) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/django/views/generic/base.py\", line 68, in view return self.dispatch(request, *args, **kwargs) File \"/Users/jetmo/.virtualenvs/shops_py3/lib/python3.6/site-packages/rest_framework/views.py\", line 480, in dispatch response = handler(request, *args, **kwargs) File \"/Users/jetmo/Documents/Code/shops/shops/shops/apps/verifications/views.py\", line 82, in get logger.info('手机: %s 发送短信ok' % mobile)Message: '手机: 15167128625 发送短信ok'Arguments: () 核心错误代码12345UnicodeEncodeError: 'ascii' codec can't encode characters in position 38-39: ordinal not in range(128).....\"/Users/jetmo/Documents/Code/shops/shops/shops/apps/verifications/views.py\", line 82, in get 按道理讲, 从出现bug就没有会想到mac编码存在问题.\b 解决办法在settings.py中的日志配置文件中添加&#39;encoding&#39;: &#39;utf-8&#39;就可以完美解决.完美代码如下:12345678910111213141516171819202122232425262728293031323334353637383940LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'formatters': &#123; 'verbose': &#123; 'format': '%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s' &#125;, 'simple': &#123; 'format': '%(levelname)s %(module)s %(lineno)d %(message)s' &#125;, &#125;, 'filters': &#123; 'require_debug_true': &#123; '()': 'django.utils.log.RequireDebugTrue', &#125;, &#125;, 'handlers': &#123; 'console': &#123; 'level': 'DEBUG', 'filters': ['require_debug_true'], 'class': 'logging.StreamHandler', 'formatter': 'simple' &#125;, 'file': &#123; 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', 'filename': os.path.join(os.path.dirname(BASE_DIR), \"logs/meiduo.log\"), # 日志文件的位置 'maxBytes': 300 * 1024 * 1024, 'backupCount': 10, 'formatter': 'verbose', 'encoding': 'utf-8' # 这里添加可以避免中文报错 &#125;, &#125;, 'loggers': &#123; # 定义了一个名为django的日志器 'django': &#123; 'handlers': ['console', 'file'], 'propagate': True, &#125;, &#125;&#125;","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/tags/django/"},{"name":"logging","slug":"logging","permalink":"https://www.leejia.me/tags/logging/"}]},{"title":"rest_framework知识点之:方法get_seriazlier","slug":"rest-framework知识点","date":"2018-09-09T07:29:44.000Z","updated":"2018-09-09T08:00:01.435Z","comments":true,"path":"django/django_rest_framework_get_seriazlier.html","link":"","permalink":"https://www.leejia.me/django/django_rest_framework_get_seriazlier.html","excerpt":"","text":"rest_framework中get_seriazlier()方法的作用. 先看案例123456789101112class SMSCodeView(GenericAPIView): \"\"\"短信验证码\"\"\" # 参数: mobile image_code_id, text serializer_class = ImageCodeCheckSerializer() def get(self, request, mobile): # 校验参数 (序列化器完成) # self.get_serializer()的目的是把request, view, format 传到序列化器中.(看源码) serializer = self.get_serializer(data=request.query_params) serializer.is_valid(raise_exception=True) ...省略代码... 这里serializer = self.get_serializer(data=request.query_params)目的有三个:1.获取序列化器.serializer_class = ImageCodeCheckSerializer().2.断言3.把request, view,format传到序列化器中,以供序列化器校验.(如果不看源码,这里会比较难理解.) 看源码123456789101112131415161718192021222324252627282930313233class GenericAPIView(views.APIView): ...无关代码省略... queryset = None serializer_class = None ...无关代码省略... def get_serializer(self, *args, **kwargs): ...无关代码省略... # 这里调用方法get_serializer_class() 目的就是返回序列化器!! serializer_class = self.get_serializer_class() # 这里目的是获取参数并分装到字典中: reques, format, view kwargs['context'] = self.get_serializer_context() # 这里目的是返回序列化器(此时已经把参数封装进去了.) return serializer_class(*args, **kwargs) def get_serializer_class(self): ...注释和断言干掉不需要看... # 这是目的是: 返回类属性:序列化器 return self.serializer_class def get_serializer_context(self): ...注释不需要看... # 这里目的是返回当前类视图的request, format, view并赋值 return &#123; 'request': self.request, 'format': self.format_kwarg, 'view': self &#125; 总结自此: 看明白才能理解为什么明明类属性中明明有序列化器我们还需要绕一大圈去获取序列化器.原因很明确,就是为了把参数传递到序列化器中,以便序列化器做校验.","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/tags/django/"},{"name":"rest_framework","slug":"rest-framework","permalink":"https://www.leejia.me/tags/rest-framework/"}]},{"title":"时间戳转换的几种方法","slug":"时间戳转换的几种方法","date":"2018-09-05T00:49:57.000Z","updated":"2018-09-05T01:01:53.989Z","comments":true,"path":"python/timestamp.html","link":"","permalink":"https://www.leejia.me/python/timestamp.html","excerpt":"","text":"格式化1234567891011# 第一种import datetimetimestamp = 1536108815 # 如果是从网页解析出来的是字符串,需要转intdateArray = datetime.datetime.utcfromtimestamp(int(timestamp))styletime = dateArray.strftime(\"%Y-%m-%d %H:%M:%S\")prtint(styletime)# 第二种ts = 1515774430dt = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(ts))print(dt) 获取时间戳123import timet = time.time()print(t) 转时间戳12345dt = '2018-02-01 02:40:30'# 先把日期字符串转为 日期对象,然后再把日期对象转为时间戳ts = int(time.mktime(time.strptime(dt, \"%Y-%m-%d %H:%M:%S\")))print (ts) 获取时间,获取时间戳,时间戳转化,python提供很多模块,可以多google.","categories":[{"name":"python","slug":"python","permalink":"https://www.leejia.me/categories/python/"}],"tags":[{"name":"时间戳","slug":"时间戳","permalink":"https://www.leejia.me/tags/时间戳/"},{"name":"timetamp","slug":"timetamp","permalink":"https://www.leejia.me/tags/timetamp/"},{"name":"datetime","slug":"datetime","permalink":"https://www.leejia.me/tags/datetime/"},{"name":"time","slug":"time","permalink":"https://www.leejia.me/tags/time/"}]},{"title":"python中url编解码问题","slug":"python中url编解码问题","date":"2018-09-04T01:22:05.000Z","updated":"2018-09-04T01:28:32.993Z","comments":true,"path":"python/python_url_decode_encode.html","link":"","permalink":"https://www.leejia.me/python/python_url_decode_encode.html","excerpt":"","text":"普通字符串的处理1234567from urllib import parsestr1 = 'haha哈哈'str2 = parse.quote(str1) #quote()将字符串进行编码print(str2) #str2=haha%E5%93%88%E5%93%88str3 = parse.unquote(str2) #解码字符串print(str3) #str3=haha哈哈 url的处理123456789101112131415from urllib import parseimport requestsurl = 'http://www.baidu.com/s?'dict1 =&#123;'wd': '百度翻译'&#125;url_data = parse.urlencode(dict1) #unlencode()将字典&#123;k1:v1,k2:v2&#125;转化为k1=v1&amp;k2=v2print(url_data) #url_data：wd=%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91data = requests.get((url+url_data)).text #读取url响应结果data = data.decode('utf-8') #将响应结果用utf8编码print(data)url_org = parse.unquote(url_data) #解码urlprint(url_org) #url_org：wd=百度翻译","categories":[{"name":"python","slug":"python","permalink":"https://www.leejia.me/categories/python/"}],"tags":[{"name":"unquote","slug":"unquote","permalink":"https://www.leejia.me/tags/unquote/"},{"name":"quote","slug":"quote","permalink":"https://www.leejia.me/tags/quote/"}]},{"title":"json和xml互转","slug":"json和xml互转","date":"2018-09-03T08:15:06.000Z","updated":"2018-09-17T02:28:11.880Z","comments":true,"path":"code/json2xml_xml2json.html","link":"","permalink":"https://www.leejia.me/code/json2xml_xml2json.html","excerpt":"","text":"json和xml互转.借助的模块xmltodict json2xml123456789101112131415161718192021import xmltodict#json转xml函数def jsontoxml(jsonstr): #xmltodict库的unparse()json转xml xmlstr = xmltodict.unparse(jsonstr) print(xmlstr)if __name__ == \"__main__\": json_str = &#123; 'student': &#123; 'course': &#123; 'name': 'math', 'score': '90' &#125;, 'info': &#123; 'sex': 'male', 'name': 'name' &#125;, 'stid': '10213' &#125; &#125; jsontoxml(json_str) xml2json123456789101112131415161718192021222324import jsonimport xmltodict#定义xml转json的函数def xmltojson(xmlstr): #parse是的xml解析器 xmlparse = xmltodict.parse(xmlstr) #json库dumps()是将dict转化成json格式，loads()是将json转化成dict格式。 #dumps()方法的ident=1，格式化json jsonstr = json.dumps(xmlparse,indent=1) print(jsonstr)if __name__ == \"__main__\": xml =\"\"\"&lt;student&gt; &lt;stid&gt;10213&lt;/stid&gt; &lt;info&gt; &lt;name&gt;name&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/info&gt; &lt;course&gt; &lt;name&gt;math&lt;/name&gt; &lt;score&gt;90&lt;/score&gt; &lt;/course&gt;&lt;/student&gt;\"\"\" xmltojson(xml) #调用转换函数","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"json","slug":"json","permalink":"https://www.leejia.me/tags/json/"},{"name":"xml","slug":"xml","permalink":"https://www.leejia.me/tags/xml/"}]},{"title":"序列化和反序列化的底层实现原理是什么？","slug":"序列化和反序列化的底层实现原理是什么？","date":"2018-09-03T07:14:10.000Z","updated":"2018-09-03T07:22:06.116Z","comments":true,"path":"django/xuliehua_fanxuliehua.html","link":"","permalink":"https://www.leejia.me/django/xuliehua_fanxuliehua.html","excerpt":"","text":"序列化和反序列化作为Java里一个较为基础的知识点，大家心里也有那么几句要说的，但我相信很多小伙伴掌握的也就是那么几句而已，如果再深究问一下Java如何实现序列化和反序列化的，就可能不知所措了！遥记当年也被问了这一个问题，自信满满的说了一大堆，什么是序列化、什么是反序列化、什么场景的时候才会用到等，然后面试官说：那你能说一下序列化和反序列化底层是如何实现的吗？一脸懵逼，然后回家等通知！ 基本概念1.什么是序列化和反序列化（1) Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；（2）序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。 （3）反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。 （4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。 2.为什么需要序列化和反序列化我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。 那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！ 换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。 当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。 总的来说可以归结为以下几点： （1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；（3）通过序列化在进程间传递对象； 3.序列化算法一般会按步骤做如下事情：（1）将对象实例相关的类元数据输出。（2）递归地输出类的超类描述直到不再有超类。（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。（4）从上至下递归输出实例的数据 …这里是Java序列化和反序列化的代码示例…. 注: 本文摘自https://blog.csdn.net/xlgen157387/article/details/79840134","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"https://www.leejia.me/tags/序列化/"},{"name":"反序列化","slug":"反序列化","permalink":"https://www.leejia.me/tags/反序列化/"},{"name":"传输","slug":"传输","permalink":"https://www.leejia.me/tags/传输/"}]},{"title":"django开发之类视图","slug":"Django开发之类视图","date":"2018-09-01T04:28:08.000Z","updated":"2018-09-02T06:24:17.896Z","comments":true,"path":"django/django_classView_decorator.html","link":"","permalink":"https://www.leejia.me/django/django_classView_decorator.html","excerpt":"","text":"Django中可以使用类来定义一个视图。称为类视图 123456789101112131415from django.views.generic import Viewfrom django.shortcuts import renderfrom django.views.generic import Viewclass RegisterView(View): \"\"\"类视图：处理注册\"\"\" def get(self, request): \"\"\"处理GET请求，返回注册页面\"\"\" return render(request, 'register.html') def post(self, request): \"\"\"处理POST请求，实现注册逻辑\"\"\" return HttpResponse('这里实现注册逻辑') 类视图使用123456# 导包from django.views.generic import View# 注册urlpatterns = [ url(r'^register/$', views.RegisterView.as_view(), name='register')] 类视图原理1类视图是继承了base.py模块中非View基类。下面是源码 12345678910111213141516171819202122232425262728class View(object): ...省略 @classonlymethod def as_view(cls, **initkwargs): # 因为我们定义的类视图，就是继承View类。所有这里cls就是指代我们定义的类对象。 ...省略 def view(request, *args, **kwargs): self = cls(**initkwargs) if hasattr(self, 'get') and not hasattr(self, 'head'): self.head = self.get self.request = request self.args = args self.kwargs = kwargs return self.dispatch(request, *args, **kwargs) ...省略 return view # 返回真正的视图函数 def dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn't exist, # defer to the error handler. Also defer to the error handler if the # request method isn't on the approved list. if request.method.lower() in self.http_method_names: handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) ...省略 类视图使用装饰器方法一 【在url配置中装饰】（类视图下所有请求方法都会被装饰【因为是在视图入口处，分发请求之前】 缺点： 单看视图无法知道添加了装饰器，不利于代码的完整性。） 12345678910111213141516171819# 第一步定义一个装饰器def my_decorator(func): def wrapper(request, *args, **kwargs): # 这里做一些额外的事情 print(\"自定义装饰器被调用了。。\") return func(request, *args, **kwargs) return wrapper# 第二步定一个类视图class DemoView(View): # 继承自View这个基类 def get(self, request): return HttpResponse(\"get...ok\") def post(self, request): return HttpResponse(\"post...ok\") # 第三步， 在url配置中装饰urlpatterns = [ url(r'^demo/$', my_decorate(DemoView.as_view()))] 方法二 【类视图中装饰】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from django.utils.decorators import method_decorator# 类视图中装饰的第一种# 为全部请求方法添加装饰器class DemoView(View): # methos_decorator()做了什么事情？处理了self,因为类中第一个变量都是self # 所以还可以直接在装饰器中，参数第一个位置添加self 而不用methos_decorator() @method_decorator(my_decorator) def dispatch(self, *args, **kwargs): return super().dispatch(*args, **kwargs) def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok')# 类视图中装饰的第二种# 为特定请求方法添加装饰器# 注意这里因为给特定方法添加装饰器，所以不需要复写父类方法。class DemoView(View): @method_decorator(my_decorator) def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') # 类视图中装饰的第三种# 为全部请求方法添加装饰器@method_decorator(my_decorator, name='dispatch')class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok')# 类视图中装饰的第四种# 为特定请求方法添加装饰器@method_decorator(my_decorator, name='get')class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为什么需要使用method_decorator? 在上面已经做了说明。下面用代码详细阐述一下。 为函数视图准备的装饰器，其被调用时，第一个参数用于接收request对象 12345def my_decorate(func): def wrapper(request, *args, **kwargs): # 第一个参数request对象 ...代码省略... return func(request, *args, **kwargs) return wrapper 而类视图中请求方法被调用时，传入的第一个参数不是request对象，而是self 视图对象本身，第二个位置参数才是request对象 123456class DemoView(View): def dispatch(self, request, *args, **kwargs): ...代码省略... def get(self, request): ...代码省略... 所以如果直接将用于函数视图的装饰器装饰类视图方法，会导致参数传递出现问题。 method_decorator的作用是为函数视图装饰器补充第一个self参数，以适配类视图方法。 如果将装饰器本身改为可以适配类视图方法的，类似如下，则无需再使用method_decorator。 123456def my_decorator(func): def wrapper(self, request, *args, **kwargs): # 此处增加了self print('自定义装饰器被调用了') print('请求路径%s' % request.path) return func(self, request, *args, **kwargs) # 此处增加了self return wrapper 方法三 构造Mixin扩展类（使用面向对象多继承的特性， 可以给多个类使用装饰器 所有请求方法否会添加装饰行为） 12345678910111213141516171819202122# 构造Mixin扩展类 不管有几个扩展类，都要继承object类class MyDecoratorMixin(object): # 重写父类的as_view()方法 @classmethod def as_view(cls, *args, **kwargs): # 调用父类的as_view()类方法 view = super().as_view(*args, **kwargs) # 使用装饰器重写父类的as_view()类方法 view = my_decorator(view) return view # 定义类视图，注意需要继承Mixin扩展类class DemoView(MyDecoratorMixin, View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok')","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/tags/django/"},{"name":"类视图","slug":"类视图","permalink":"https://www.leejia.me/tags/类视图/"},{"name":"装饰器","slug":"装饰器","permalink":"https://www.leejia.me/tags/装饰器/"},{"name":"as_view","slug":"as-view","permalink":"https://www.leejia.me/tags/as-view/"}]},{"title":"mkvirtualenv创建虚拟环境报错没有stevedore模块解决方案","slug":"mkvirtualenv创建虚拟环境报错没有stevedore模块解决方案","date":"2018-08-30T04:57:41.000Z","updated":"2018-09-21T10:36:47.437Z","comments":true,"path":"code/mkvirtualenv-stevedore-error.html","link":"","permalink":"https://www.leejia.me/code/mkvirtualenv-stevedore-error.html","excerpt":"","text":"事发有因一直以来我都是使用virtualenv venv来创建虚拟环境的.然后使用source venv/bin/activate激活虚拟环境. 虚拟环境越来越多,于是尝试使用virtualenvwrapper来管理虚拟环境.pip install virtualenvwrapper 没有问题.但是使用mkvirtualenv创建虚拟环境出现如下错误: 1234567891011121314JetmodeMacBook-Pro➜ ~ ᐅ mkvirtualenv dj -p python3Already using interpreter /Library/Frameworks/Python.framework/Versions/3.6/bin/python3Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6'New python executable in /Users/jetmo/.virtualenvs/dj/bin/python3Also creating executable in /Users/jetmo/.virtualenvs/dj/bin/pythonInstalling setuptools, pip, wheel...done.Traceback (most recent call last): File \"/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py\", line 174, in _run_module_as_main \"__main__\", fname, loader, pkg_name) File \"/usr/local/Cellar/python@2/2.7.15_1/Frameworks/Python.framework/Versions/2.7/lib/python2.7/runpy.py\", line 72, in _run_code exec code in run_globals File \"/usr/local/lib/python2.7/site-packages/virtualenvwrapper-4.8.2-py2.7.egg/virtualenvwrapper/hook_loader.py\", line 16, in &lt;module&gt; from stevedore import ExtensionManagerImportError: No module named stevedore debug原因是缺少stevedore模块.直接安装会继续报错,多次尝试后找到了解决办法. 方案使用pip2安装很多同学应该都是默认pip3版本,但是这个模块一定要使用pip2安装(我是这样的). zsh中键入pip后两次tab键找到选择pip212sudo pip2 uninstall stevedore # 先卸载sudo pip2 install stevedore # 再安装 然后再使用mkvirtualenv django_py3 -p python3 安装虚拟环境就不会报错了. 延伸(虚拟环境)安装12sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper 配置12345678910# 1、创建目录用来存放虚拟环境mkdir $HOME/.virtualenvs# 2、打开~/.bashrc文件，并添加如下：export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh# 3、运行source ~/.bashrc 创建虚拟环境1mkvirtualenv -p python3 虚拟环境名称 激活虚拟环境1workon 虚拟环境名称 退出虚拟环境1deactivate 删除虚拟环境1rmvirtualenv 虚拟环境名称","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"stevedore","slug":"stevedore","permalink":"https://www.leejia.me/tags/stevedore/"},{"name":"virtualenv","slug":"virtualenv","permalink":"https://www.leejia.me/tags/virtualenv/"}]},{"title":"最简单的django程序","slug":"最简单的django程序","date":"2018-08-30T02:47:00.000Z","updated":"2018-08-30T02:47:00.000Z","comments":true,"path":"django/tiny-django-app.html","link":"","permalink":"https://www.leejia.me/django/tiny-django-app.html","excerpt":"","text":"最简单的django程序.包含创建工程,创建一个app,配置url,编辑视图函数, 注册app 创建工程12django-admin startproject django_democd django_demo 创建app1python manage.py startapp users 注册app12# 在settings.py中users.apps.UsersConfig 编辑视图函数123456789101112# app中 views模块中from django.http import HttpResponse# Create your views here.def index(request): \"\"\" 视图函数 :param request: django 默认的第一个参数,用户接收request请求 :return: 响应对象 \"\"\" return HttpResponse(\"这是用户界面\") 添加视图url123456789# app中创建urls模块from django.conf.urls import urlfrom . import viewsurlpatterns = [ # url(路径, 视图) url(r'^index/$', views.index),] url前缀123456789# 在全局urls中配置appfrom django.conf.urls import url, include...# 类比flask中蓝图前缀urlpatterns = [ ... url(r'^users/', include('users.urls')),] 启动工程1python manage.py runserver 访问1http://127.0.0.1:8000/users/index","categories":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"https://www.leejia.me/tags/django/"},{"name":"python","slug":"python","permalink":"https://www.leejia.me/tags/python/"}]},{"title":"centos下启动flask程序","slug":"centos下启动flask程序","date":"2018-08-29T06:49:24.000Z","updated":"2018-08-30T10:53:09.216Z","comments":true,"path":"flask/centos-start-flask.html","link":"","permalink":"https://www.leejia.me/flask/centos-start-flask.html","excerpt":"","text":"centos系统下安装ngnix(负责转发)1yum install ngnix 配置ngnix1配置文件路径: /etc/nginx/nginx.conf 123456789101112131415161718192021222324252627# 如果是多台服务器的话，则在此配置，并修改 location 节点下面的 proxy_pass upstream flask &#123; server 127.0.0.1:5000; server 127.0.0.1:5001;&#125;server &#123; # 监听80端口 listen 80 default_server; listen [::]:80 default_server; root /var/www/html; index index.html index.htm index.nginx-debian.html; server_name _; location / &#123; # 请求转发到gunicorn服务器 proxy_pass http://127.0.0.1:5000; # 请求转发到多个gunicorn服务器 # proxy_pass http://flask; # 设置请求头，并将头信息传递给服务器端 proxy_set_header Host $host; # 设置请求头，传递原始请求ip给 gunicorn 服务器 proxy_set_header X-Real-IP $remote_addr; &#125;&#125; 启动ngnix服务器 1nginx -c /etc/nginx/nginx.conf python虚拟环境中安装 Gunicorn(wsgi协议的服务器) 1pip install Gunicorn 启动\bGunicorn 进入flask程序的启动文件所在文件夹.比如我的启动文件是manage.py那么运行命令就是:1gunicorn -w 2 -b 127.0.0.1:5000 manage:app -D --reload 1参数含义: -D表示后台运行. --reload表示重启Gunicorn.已经运行的会重新启动不必要去kill进程.","categories":[{"name":"flask","slug":"flask","permalink":"https://www.leejia.me/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://www.leejia.me/tags/flask/"},{"name":"ngnix","slug":"ngnix","permalink":"https://www.leejia.me/tags/ngnix/"}]},{"title":"关于centos操作系统安装mysqlclient失败的解决方案","slug":"关于centos操作系统安装mysqlclient失败的解决方案","date":"2018-08-29T01:50:19.000Z","updated":"2018-08-30T10:50:54.923Z","comments":true,"path":"flask/mysqlclientpython.html","link":"","permalink":"https://www.leejia.me/flask/mysqlclientpython.html","excerpt":"","text":"使用CentOS基本源安装Python2链接库1yum install python-devel 使用CentOS EPEL源安装Python3对应版本的链接库包1yum install python34-devel 现在再安装mysqlclient就不会出现编译中断。 1error: command 'gcc' failed with exit status 1 这样的错误了. 安装: 1pip install mysqlclient 后续再安装Flask-MySQLdb 也不会报错啦.安装: 1pip install flask-mysqldb","categories":[{"name":"flask","slug":"flask","permalink":"https://www.leejia.me/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"https://www.leejia.me/tags/flask/"},{"name":"mysqlclient","slug":"mysqlclient","permalink":"https://www.leejia.me/tags/mysqlclient/"}]},{"title":"关于centos操作系统安装MySQL-python失败的解决方案","slug":"关于centos操作系统安装MySQL-python失败的解决方案","date":"2018-08-29T01:42:03.000Z","updated":"2018-08-30T10:50:39.476Z","comments":true,"path":"flask/centos-have-no-mysql.html","link":"","permalink":"https://www.leejia.me/flask/centos-have-no-mysql.html","excerpt":"","text":"flask迁移数据库的时候会出现.找不到mysqldb模块这样的情况.在centos系统上方案一就可以有效解决.但是在ubuntu 16.04上推荐优先使用方案二. 原因MySQLdb不支持python3.x 方案一centos 使用yum 是找不到YSQL-python这个包的.所以需要下载安装包执行安装. 安装完依赖包后，开始安装MYSQL-python： 1、下载tar包： 执行： 1wget https://pypi.python.org/packages/c8/8f/aedf47a2e973a2d2f225ac98537472fc928ad61b9647fb370870404c594b/MySQL-python-1.2.3c1.tar.gz#md5=310dd856e439d070b59ece6dd7a0734d 完成tar下载 2、解压执行： 1tar -xzvf MySQL-python-1.2.3c1.tar.gz 进入解压之后的文件夹根目录 3、编译(用python2 如果在python3虚拟环境请退出虚拟环境) 1python setup.py build 4、安装(用python2 如果在python3虚拟环境请退出虚拟环境) 1python setup.py install 经过上述步骤就完成了MySQL-python 方案二如果还是不能解决问题可以尝试:用pymysql来代替MySQLdb具体位置:__init.py__,manage.py12import pymysqlpymysql.install_as_MySQLdb()","categories":[{"name":"flask","slug":"flask","permalink":"https://www.leejia.me/categories/flask/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://www.leejia.me/tags/centos/"},{"name":"MYSQL-python","slug":"MYSQL-python","permalink":"https://www.leejia.me/tags/MYSQL-python/"},{"name":"mysql","slug":"mysql","permalink":"https://www.leejia.me/tags/mysql/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-16T05:04:29.784Z","updated":"2018-09-17T02:28:01.076Z","comments":true,"path":"code/hello-world.html","link":"","permalink":"https://www.leejia.me/code/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[]},{"title":"git基本命令","slug":"git","date":"2018-08-16T04:56:12.000Z","updated":"2018-09-17T02:27:50.815Z","comments":true,"path":"code/git.html","link":"","permalink":"https://www.leejia.me/code/git.html","excerpt":"","text":"git init 初始化git,当前文件夹使用git管理 git add . 添加到暂存区 git commit -m “修改明细” 提交到本地仓库 git status 查看状态 git push 推送到远程服务器 git pull 从远程服务器拉取代码 git log / reflog 查看日记 git reset HEAD^ 回退到上一个版本或者指定版本 git reset –hard 589e122 回退到指定版本 git diff 对比 git rm 删除 git checkout 检查 标签 git tag -a v1.0 -m “version 1.0” 给项目打标签 git push origin v1.0 push到远程服务器 git brach 查看当前分支 git checkout -b dev 创建dev 分支 git push -u origin dev 把当前分支同步到服务器 git checkout master 切换分支 git merge dev 合并分支","categories":[{"name":"code","slug":"code","permalink":"https://www.leejia.me/categories/code/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.leejia.me/tags/git/"},{"name":"github","slug":"github","permalink":"https://www.leejia.me/tags/github/"}]}]}